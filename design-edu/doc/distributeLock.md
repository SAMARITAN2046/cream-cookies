# 分布式锁

## 导读  

  在分布式部署·高并发·多线程场景下，经常遇到资源互斥访问问题。最有效·最普遍的方法是给共享资源或共享资源的操作加一把锁。在JDK中，我们经常使用`ReentrantLock` 重入锁或者`synchronize` 关键字解决资源互斥访问问题，但是由于分布式系统的分布性（多线程和多进程并且分布在不同的机器中，使得两种锁都失去了原有的效果，需要使用自定义的分布式锁来解决问题。

- 什么是分布式锁？分布式锁具备哪些条件？分布式锁有哪些实现方式？

## 分布式锁

分布式锁是控制分布式系统之间同步访问共享资源的一种方式，用于控制共享资源访问的手段。如果不同的系统是同一个系统的不同主机实例共享访问一个或者一组资源，那么在访问这些资源的时候，往往需要互斥来防止资源数量或者状态的一致性，在这种情况下需要使用分布式锁，分布式锁通过共享标识确定唯一性，对共享标识进行修改是能够保证原子性和对锁服务调用方的可见性。

### 分布式锁概览

一般认为分布式锁主要使用在下面两个场景：

- 效率： 使用分布式锁可以避免不同节点重复相同的工作浪费资源，比如通知系统，对同一个系统做出了多次同样的通知。
- 正确性： 添加分布式锁能够避免破坏事件或者数据的正确性，如果两个节点在同一条数据上面操作，比如多个节点实例对同一个订单操作不同的流程，可能导致最后订单状态的出现错误，造成资金损失。

分布式锁需要具备的条件包括：

- 获取锁和释放锁的性能要好。
- 判断获得锁是否是原子性的，否则可能导致多个请求都可以获取到锁。
- 网络中断或者宕机，锁的持有者无法主动释放锁，锁必须清楚。
- 锁具有可重入性。比如，一个获取锁的线程在执行带锁的方法，改方法调用另外一个需要相同锁的方法，则改线程直接执行调用方法而无需再次获得锁。
- 阻塞锁和非阻塞锁，阻塞锁为没有获取到锁，则继续等待。非阻塞锁为没有获取到锁，不进行等待直接返回竞争锁失败。

### 分布式锁实现

分布式CAP理论说明，“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance），最多只能保证两项完成，在互联网领域的绝大多数场景，都需要强一致性来换取系统的高可用性，只需要打到最终一致性，当然最终在用户的容忍度范围之内”。在很多场景，为了保证数据的最终一致性，需要多种技术方案的支持，比如分布式事务，分布式锁等等。

分布式锁一般有三种实现方式：

- 基于数据库实现分布式锁
- 基于缓存（` Redis ` ，`Memcached` )实现分布式锁； 
- 基于`Zookeeper` 实现分布式锁；

#### 基于数据库实现分布式锁

基于数据库实现分布式锁的核心思想：在数据库中创建一张表，表里面包含方法名等字段，并且在方法名字段上创建唯一索引，执行某个方法的需要使用此方法名向表中插入数据，成功插入数据则获取锁，执行结束删除对应的行数据释放锁。

#### 基于缓存实现分布式锁

基于缓存实现通常选中`Redis` 实现分布式锁，Redis的性能非常高，Redis命令对分布式锁支持友好，提供了方便的API，实现非常容易。基于单Redis节点的分布式锁在Failover 的时候产生了解决不了的安全性问题。RedLock是Redis作者提出的集群模式的Redis分布式锁，基于N个完全独立的Redis节点（eg：N=5），运行Redlock算法基本步骤如下（来源于Redis文档）

- 获取当前时间（毫秒数）；
- 按顺序依次向 N 个 Redis 节点执行获取锁的操作。此获取操作包含随机字符串 myrandomvalue，也包含过期时间(比如 PX 30000，即锁的有效时间)。为了保证在某个 Redis 节点不可用的时候算法能够继续运行，获取锁的操作还有超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个 Redis 节点获取锁失败以后应该立即尝试下一个Redis 节点。这里的失败包含任何类型的失败，比如该 Redis 节点不可用，或者该 Redis 节点上的锁已经被其它客户端持有；
- 计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数 Redis 节点（>= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间（lock validity time），那么这时客户端才认为最终获取锁成功；否则认为最终获取锁失败；
- 如果最终获取锁成功了，那么此锁的有效时间应该重新计算，它等于最初锁的有效时间减去第3步计算出来的获取锁消耗的时间；
- 如果最终获取锁失败（可能由于获取到锁的 Redis 节点个数少于 N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端立即向所有 Redis 节点发起释放锁的操作；

#### 基于Zookeeper实现分布式锁

ZooKeeper 是以 Paxos（Zab） 算法为基础的分布式应用程序协调服务，为分布式应用提供一致性服务的开源组件，其内部是分层的树形文件目录结构，规定同一个目录下只能有一个唯一文件名。基于 ZooKeeper 实现分布式锁步骤包括：

- 创建一个锁目录lock
- 希望获得锁的线程 A 在 lock 目录下创建**临时顺序节点**；
- 当前线程获取锁目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在表示当前线程顺序号最小，获得锁；
- 线程 B 获取所有节点，判断自己不是最小节点，设置监听（Watcher）比自己次小的节点（只关注比自己次小的节点是为了防止发生“羊群效应”）
- 线程 A 处理完删除自己的节点，线程 B 监听到变更事件判断自己是否为最小的节点，如果是则获得锁；